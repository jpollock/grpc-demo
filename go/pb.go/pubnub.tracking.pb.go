// Code generated by protoc-gen-go. DO NOT EDIT.
// source: pubnub.tracking.proto

package pubnub

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	_struct "github.com/golang/protobuf/ptypes/struct"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type DriverTrackingMessage_DriverStatus int32

const (
	DriverTrackingMessage_CUSTOM                 DriverTrackingMessage_DriverStatus = 0
	DriverTrackingMessage_UNAVAILABLE            DriverTrackingMessage_DriverStatus = 1
	DriverTrackingMessage_WAITING_FOR_ASSIGNMENT DriverTrackingMessage_DriverStatus = 2
	DriverTrackingMessage_EN_ROUTE_TO_PICKUP     DriverTrackingMessage_DriverStatus = 3
	DriverTrackingMessage_EN_ROUTE_TO_DELIVER    DriverTrackingMessage_DriverStatus = 4
)

var DriverTrackingMessage_DriverStatus_name = map[int32]string{
	0: "CUSTOM",
	1: "UNAVAILABLE",
	2: "WAITING_FOR_ASSIGNMENT",
	3: "EN_ROUTE_TO_PICKUP",
	4: "EN_ROUTE_TO_DELIVER",
}

var DriverTrackingMessage_DriverStatus_value = map[string]int32{
	"CUSTOM":                 0,
	"UNAVAILABLE":            1,
	"WAITING_FOR_ASSIGNMENT": 2,
	"EN_ROUTE_TO_PICKUP":     3,
	"EN_ROUTE_TO_DELIVER":    4,
}

func (x DriverTrackingMessage_DriverStatus) String() string {
	return proto.EnumName(DriverTrackingMessage_DriverStatus_name, int32(x))
}

func (DriverTrackingMessage_DriverStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0ced5c706461a59b, []int{1, 0}
}

type LocationTrackingMessage_TrackingStatus int32

const (
	LocationTrackingMessage_CUSTOM              LocationTrackingMessage_TrackingStatus = 0
	LocationTrackingMessage_READY_FOR_PICKUP    LocationTrackingMessage_TrackingStatus = 1
	LocationTrackingMessage_EN_ROUTE_TO_DELIVER LocationTrackingMessage_TrackingStatus = 2
	LocationTrackingMessage_DELIVERED           LocationTrackingMessage_TrackingStatus = 3
	LocationTrackingMessage_UNABLE_TO_DELIVER   LocationTrackingMessage_TrackingStatus = 4
	LocationTrackingMessage_RETURNING           LocationTrackingMessage_TrackingStatus = 5
	LocationTrackingMessage_CLOSED              LocationTrackingMessage_TrackingStatus = 6
	LocationTrackingMessage_EXCEPTION           LocationTrackingMessage_TrackingStatus = 7
)

var LocationTrackingMessage_TrackingStatus_name = map[int32]string{
	0: "CUSTOM",
	1: "READY_FOR_PICKUP",
	2: "EN_ROUTE_TO_DELIVER",
	3: "DELIVERED",
	4: "UNABLE_TO_DELIVER",
	5: "RETURNING",
	6: "CLOSED",
	7: "EXCEPTION",
}

var LocationTrackingMessage_TrackingStatus_value = map[string]int32{
	"CUSTOM":              0,
	"READY_FOR_PICKUP":    1,
	"EN_ROUTE_TO_DELIVER": 2,
	"DELIVERED":           3,
	"UNABLE_TO_DELIVER":   4,
	"RETURNING":           5,
	"CLOSED":              6,
	"EXCEPTION":           7,
}

func (x LocationTrackingMessage_TrackingStatus) String() string {
	return proto.EnumName(LocationTrackingMessage_TrackingStatus_name, int32(x))
}

func (LocationTrackingMessage_TrackingStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0ced5c706461a59b, []int{3, 0}
}

type DriverTrackingEnvelope struct {
	Channel              string                 `protobuf:"bytes,1,opt,name=channel,proto3" json:"channel,omitempty"`
	Data                 *DriverTrackingMessage `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *DriverTrackingEnvelope) Reset()         { *m = DriverTrackingEnvelope{} }
func (m *DriverTrackingEnvelope) String() string { return proto.CompactTextString(m) }
func (*DriverTrackingEnvelope) ProtoMessage()    {}
func (*DriverTrackingEnvelope) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ced5c706461a59b, []int{0}
}

func (m *DriverTrackingEnvelope) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DriverTrackingEnvelope.Unmarshal(m, b)
}
func (m *DriverTrackingEnvelope) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DriverTrackingEnvelope.Marshal(b, m, deterministic)
}
func (m *DriverTrackingEnvelope) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DriverTrackingEnvelope.Merge(m, src)
}
func (m *DriverTrackingEnvelope) XXX_Size() int {
	return xxx_messageInfo_DriverTrackingEnvelope.Size(m)
}
func (m *DriverTrackingEnvelope) XXX_DiscardUnknown() {
	xxx_messageInfo_DriverTrackingEnvelope.DiscardUnknown(m)
}

var xxx_messageInfo_DriverTrackingEnvelope proto.InternalMessageInfo

func (m *DriverTrackingEnvelope) GetChannel() string {
	if m != nil {
		return m.Channel
	}
	return ""
}

func (m *DriverTrackingEnvelope) GetData() *DriverTrackingMessage {
	if m != nil {
		return m.Data
	}
	return nil
}

type DriverTrackingMessage struct {
	DriverId             string                             `protobuf:"bytes,1,opt,name=driver_id,json=driverId,proto3" json:"driver_id,omitempty"`
	OrderId              string                             `protobuf:"bytes,2,opt,name=order_id,json=orderId,proto3" json:"order_id,omitempty"`
	DriverStatus         DriverTrackingMessage_DriverStatus `protobuf:"varint,3,opt,name=driver_status,json=driverStatus,proto3,enum=pubnub.DriverTrackingMessage_DriverStatus" json:"driver_status,omitempty"`
	CustomStatus         *_struct.Value                     `protobuf:"bytes,4,opt,name=custom_status,json=customStatus,proto3" json:"custom_status,omitempty"`
	Location             *Location                          `protobuf:"bytes,5,opt,name=location,proto3" json:"location,omitempty"`
	Heading              float32                            `protobuf:"fixed32,6,opt,name=heading,proto3" json:"heading,omitempty"`
	Velocity             float32                            `protobuf:"fixed32,7,opt,name=velocity,proto3" json:"velocity,omitempty"`
	Road                 string                             `protobuf:"bytes,8,opt,name=road,proto3" json:"road,omitempty"`
	Metadata             *_struct.Value                     `protobuf:"bytes,9,opt,name=metadata,proto3" json:"metadata,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                           `json:"-"`
	XXX_unrecognized     []byte                             `json:"-"`
	XXX_sizecache        int32                              `json:"-"`
}

func (m *DriverTrackingMessage) Reset()         { *m = DriverTrackingMessage{} }
func (m *DriverTrackingMessage) String() string { return proto.CompactTextString(m) }
func (*DriverTrackingMessage) ProtoMessage()    {}
func (*DriverTrackingMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ced5c706461a59b, []int{1}
}

func (m *DriverTrackingMessage) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DriverTrackingMessage.Unmarshal(m, b)
}
func (m *DriverTrackingMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DriverTrackingMessage.Marshal(b, m, deterministic)
}
func (m *DriverTrackingMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DriverTrackingMessage.Merge(m, src)
}
func (m *DriverTrackingMessage) XXX_Size() int {
	return xxx_messageInfo_DriverTrackingMessage.Size(m)
}
func (m *DriverTrackingMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_DriverTrackingMessage.DiscardUnknown(m)
}

var xxx_messageInfo_DriverTrackingMessage proto.InternalMessageInfo

func (m *DriverTrackingMessage) GetDriverId() string {
	if m != nil {
		return m.DriverId
	}
	return ""
}

func (m *DriverTrackingMessage) GetOrderId() string {
	if m != nil {
		return m.OrderId
	}
	return ""
}

func (m *DriverTrackingMessage) GetDriverStatus() DriverTrackingMessage_DriverStatus {
	if m != nil {
		return m.DriverStatus
	}
	return DriverTrackingMessage_CUSTOM
}

func (m *DriverTrackingMessage) GetCustomStatus() *_struct.Value {
	if m != nil {
		return m.CustomStatus
	}
	return nil
}

func (m *DriverTrackingMessage) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *DriverTrackingMessage) GetHeading() float32 {
	if m != nil {
		return m.Heading
	}
	return 0
}

func (m *DriverTrackingMessage) GetVelocity() float32 {
	if m != nil {
		return m.Velocity
	}
	return 0
}

func (m *DriverTrackingMessage) GetRoad() string {
	if m != nil {
		return m.Road
	}
	return ""
}

func (m *DriverTrackingMessage) GetMetadata() *_struct.Value {
	if m != nil {
		return m.Metadata
	}
	return nil
}

type LocationTrackingEnvelope struct {
	Channel              string                   `protobuf:"bytes,1,opt,name=channel,proto3" json:"channel,omitempty"`
	Data                 *LocationTrackingMessage `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *LocationTrackingEnvelope) Reset()         { *m = LocationTrackingEnvelope{} }
func (m *LocationTrackingEnvelope) String() string { return proto.CompactTextString(m) }
func (*LocationTrackingEnvelope) ProtoMessage()    {}
func (*LocationTrackingEnvelope) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ced5c706461a59b, []int{2}
}

func (m *LocationTrackingEnvelope) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LocationTrackingEnvelope.Unmarshal(m, b)
}
func (m *LocationTrackingEnvelope) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LocationTrackingEnvelope.Marshal(b, m, deterministic)
}
func (m *LocationTrackingEnvelope) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocationTrackingEnvelope.Merge(m, src)
}
func (m *LocationTrackingEnvelope) XXX_Size() int {
	return xxx_messageInfo_LocationTrackingEnvelope.Size(m)
}
func (m *LocationTrackingEnvelope) XXX_DiscardUnknown() {
	xxx_messageInfo_LocationTrackingEnvelope.DiscardUnknown(m)
}

var xxx_messageInfo_LocationTrackingEnvelope proto.InternalMessageInfo

func (m *LocationTrackingEnvelope) GetChannel() string {
	if m != nil {
		return m.Channel
	}
	return ""
}

func (m *LocationTrackingEnvelope) GetData() *LocationTrackingMessage {
	if m != nil {
		return m.Data
	}
	return nil
}

type LocationTrackingMessage struct {
	TrackingId           string                                 `protobuf:"bytes,1,opt,name=tracking_id,json=trackingId,proto3" json:"tracking_id,omitempty"`
	TrackingStatus       LocationTrackingMessage_TrackingStatus `protobuf:"varint,2,opt,name=tracking_status,json=trackingStatus,proto3,enum=pubnub.LocationTrackingMessage_TrackingStatus" json:"tracking_status,omitempty"`
	CustomStatus         *_struct.Value                         `protobuf:"bytes,3,opt,name=custom_status,json=customStatus,proto3" json:"custom_status,omitempty"`
	Location             *Location                              `protobuf:"bytes,4,opt,name=location,proto3" json:"location,omitempty"`
	Metadata             *_struct.Value                         `protobuf:"bytes,5,opt,name=metadata,proto3" json:"metadata,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                               `json:"-"`
	XXX_unrecognized     []byte                                 `json:"-"`
	XXX_sizecache        int32                                  `json:"-"`
}

func (m *LocationTrackingMessage) Reset()         { *m = LocationTrackingMessage{} }
func (m *LocationTrackingMessage) String() string { return proto.CompactTextString(m) }
func (*LocationTrackingMessage) ProtoMessage()    {}
func (*LocationTrackingMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_0ced5c706461a59b, []int{3}
}

func (m *LocationTrackingMessage) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LocationTrackingMessage.Unmarshal(m, b)
}
func (m *LocationTrackingMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LocationTrackingMessage.Marshal(b, m, deterministic)
}
func (m *LocationTrackingMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LocationTrackingMessage.Merge(m, src)
}
func (m *LocationTrackingMessage) XXX_Size() int {
	return xxx_messageInfo_LocationTrackingMessage.Size(m)
}
func (m *LocationTrackingMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_LocationTrackingMessage.DiscardUnknown(m)
}

var xxx_messageInfo_LocationTrackingMessage proto.InternalMessageInfo

func (m *LocationTrackingMessage) GetTrackingId() string {
	if m != nil {
		return m.TrackingId
	}
	return ""
}

func (m *LocationTrackingMessage) GetTrackingStatus() LocationTrackingMessage_TrackingStatus {
	if m != nil {
		return m.TrackingStatus
	}
	return LocationTrackingMessage_CUSTOM
}

func (m *LocationTrackingMessage) GetCustomStatus() *_struct.Value {
	if m != nil {
		return m.CustomStatus
	}
	return nil
}

func (m *LocationTrackingMessage) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *LocationTrackingMessage) GetMetadata() *_struct.Value {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func init() {
	proto.RegisterEnum("pubnub.DriverTrackingMessage_DriverStatus", DriverTrackingMessage_DriverStatus_name, DriverTrackingMessage_DriverStatus_value)
	proto.RegisterEnum("pubnub.LocationTrackingMessage_TrackingStatus", LocationTrackingMessage_TrackingStatus_name, LocationTrackingMessage_TrackingStatus_value)
	proto.RegisterType((*DriverTrackingEnvelope)(nil), "pubnub.DriverTrackingEnvelope")
	proto.RegisterType((*DriverTrackingMessage)(nil), "pubnub.DriverTrackingMessage")
	proto.RegisterType((*LocationTrackingEnvelope)(nil), "pubnub.LocationTrackingEnvelope")
	proto.RegisterType((*LocationTrackingMessage)(nil), "pubnub.LocationTrackingMessage")
}

func init() { proto.RegisterFile("pubnub.tracking.proto", fileDescriptor_0ced5c706461a59b) }

var fileDescriptor_0ced5c706461a59b = []byte{
	// 668 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x93, 0x4b, 0x53, 0xd3, 0x50,
	0x14, 0xc7, 0x49, 0x5b, 0xfa, 0x38, 0x40, 0x89, 0x47, 0x28, 0xb1, 0x3e, 0xe8, 0x74, 0xd5, 0x71,
	0x9c, 0x80, 0x65, 0xe9, 0xaa, 0xd2, 0x6b, 0x8d, 0x96, 0xb4, 0x93, 0xa6, 0xa0, 0xab, 0x4e, 0x1e,
	0xd7, 0x92, 0xb1, 0x24, 0x9d, 0x3c, 0x18, 0x59, 0xfb, 0x31, 0x5c, 0xb9, 0xf2, 0xeb, 0xf8, 0x91,
	0x9c, 0xdc, 0xe4, 0x96, 0x06, 0x81, 0xa2, 0xbb, 0x9c, 0x73, 0xfe, 0xe7, 0x9e, 0x93, 0xff, 0xfd,
	0x5d, 0xd8, 0x9d, 0x47, 0xa6, 0x1b, 0x99, 0x72, 0xe8, 0x1b, 0xd6, 0x57, 0xc7, 0x9d, 0xca, 0x73,
	0xdf, 0x0b, 0x3d, 0x2c, 0x26, 0xe9, 0xfa, 0xb3, 0xa9, 0xe7, 0x4d, 0x67, 0xf4, 0x80, 0x65, 0xcd,
	0xe8, 0xcb, 0x41, 0x10, 0xfa, 0x91, 0x15, 0x26, 0xaa, 0x3a, 0xf2, 0xe6, 0xab, 0x39, 0x0d, 0x92,
	0x5c, 0x93, 0x42, 0xad, 0xeb, 0x3b, 0x97, 0xd4, 0xd7, 0xd3, 0x13, 0x89, 0x7b, 0x49, 0x67, 0xde,
	0x9c, 0xa2, 0x04, 0x25, 0xeb, 0xdc, 0x70, 0x5d, 0x3a, 0x93, 0x84, 0x86, 0xd0, 0xaa, 0x68, 0x3c,
	0xc4, 0xd7, 0x50, 0xb0, 0x8d, 0xd0, 0x90, 0x72, 0x0d, 0xa1, 0xb5, 0xd1, 0x7e, 0x2e, 0xa7, 0xc7,
	0x66, 0xcf, 0x39, 0xa1, 0x41, 0x60, 0x4c, 0xa9, 0xc6, 0xa4, 0xcd, 0xef, 0x05, 0xd8, 0xbd, 0xb5,
	0x8e, 0x4f, 0xa1, 0x62, 0xb3, 0xc2, 0xc4, 0xb1, 0xd3, 0x41, 0xe5, 0x24, 0xa1, 0xd8, 0xf8, 0x04,
	0xca, 0x9e, 0x6f, 0x27, 0xb5, 0x5c, 0xb2, 0x04, 0x8b, 0x15, 0x1b, 0x07, 0xb0, 0x95, 0xf6, 0x05,
	0xa1, 0x11, 0x46, 0x81, 0x94, 0x6f, 0x08, 0xad, 0x6a, 0xfb, 0xe5, 0xbd, 0xdb, 0xa4, 0xd9, 0x11,
	0xeb, 0xd0, 0x36, 0xed, 0xa5, 0x08, 0xdf, 0xc0, 0x96, 0x15, 0x05, 0xa1, 0x77, 0xc1, 0x0f, 0x2c,
	0xb0, 0xdf, 0xab, 0xc9, 0x89, 0xa7, 0x32, 0xf7, 0x54, 0x3e, 0x35, 0x66, 0x11, 0xd5, 0x36, 0x13,
	0x71, 0xda, 0xfc, 0x0a, 0xca, 0x33, 0xcf, 0x32, 0x42, 0xc7, 0x73, 0xa5, 0x75, 0xd6, 0x27, 0xf2,
	0x45, 0xfa, 0x69, 0x5e, 0x5b, 0x28, 0x62, 0x6b, 0xcf, 0xa9, 0x61, 0x3b, 0xee, 0x54, 0x2a, 0x36,
	0x84, 0x56, 0x4e, 0xe3, 0x21, 0xd6, 0xa1, 0x1c, 0xdb, 0x6f, 0x39, 0xe1, 0x95, 0x54, 0x62, 0xa5,
	0x45, 0x8c, 0x08, 0x05, 0xdf, 0x33, 0x6c, 0xa9, 0xcc, 0x8c, 0x60, 0xdf, 0xd8, 0x86, 0xf2, 0x05,
	0x0d, 0x0d, 0x76, 0x1d, 0x95, 0x7b, 0xf7, 0x5d, 0xe8, 0x9a, 0xdf, 0x60, 0x73, 0xd9, 0x06, 0x04,
	0x28, 0x1e, 0x8f, 0x47, 0xfa, 0xe0, 0x44, 0x5c, 0xc3, 0x6d, 0xd8, 0x18, 0xab, 0x9d, 0xd3, 0x8e,
	0xd2, 0xef, 0xbc, 0xed, 0x13, 0x51, 0xc0, 0x3a, 0xd4, 0xce, 0x3a, 0x8a, 0xae, 0xa8, 0xbd, 0xc9,
	0xbb, 0x81, 0x36, 0xe9, 0x8c, 0x46, 0x4a, 0x4f, 0x3d, 0x21, 0xaa, 0x2e, 0xe6, 0xb0, 0x06, 0x48,
	0xd4, 0x89, 0x36, 0x18, 0xeb, 0x64, 0xa2, 0x0f, 0x26, 0x43, 0xe5, 0xf8, 0xe3, 0x78, 0x28, 0xe6,
	0x71, 0x0f, 0x1e, 0x2f, 0xe7, 0xbb, 0xa4, 0xaf, 0x9c, 0x12, 0x4d, 0x2c, 0x34, 0x1d, 0x90, 0xb8,
	0x1b, 0xff, 0x80, 0xdb, 0x51, 0x06, 0xb7, 0xfd, 0x9b, 0xbe, 0xde, 0x0e, 0xdc, 0xef, 0x3c, 0xec,
	0xdd, 0xa1, 0xc0, 0x7d, 0xd8, 0xe0, 0xef, 0xe7, 0x1a, 0x3a, 0xe0, 0x29, 0xc5, 0xc6, 0x33, 0xd8,
	0x5e, 0x08, 0x52, 0x18, 0x72, 0x8c, 0x2e, 0x79, 0xc5, 0x70, 0x99, 0xc7, 0x29, 0x61, 0xd5, 0x30,
	0x13, 0xff, 0xcd, 0x58, 0xfe, 0x3f, 0x19, 0x2b, 0xac, 0x64, 0x6c, 0x99, 0x8c, 0xf5, 0x07, 0x92,
	0xf1, 0x43, 0x80, 0x6a, 0xf6, 0x0f, 0x32, 0x70, 0xec, 0x80, 0xa8, 0x91, 0x4e, 0xf7, 0x33, 0x23,
	0x21, 0xbd, 0x6d, 0xe1, 0xae, 0xdb, 0xce, 0xe1, 0x16, 0x54, 0xd2, 0x80, 0x74, 0xc5, 0x3c, 0xee,
	0xc2, 0xa3, 0xb1, 0x1a, 0x53, 0x95, 0x61, 0x22, 0x56, 0x69, 0x44, 0x1f, 0x6b, 0xaa, 0xa2, 0xf6,
	0xc4, 0x75, 0x36, 0xaf, 0x3f, 0x18, 0x91, 0xae, 0x58, 0x8c, 0x4b, 0xe4, 0xd3, 0x31, 0x19, 0xea,
	0xca, 0x40, 0x15, 0x4b, 0xed, 0x9f, 0x02, 0x54, 0xb3, 0xaf, 0x1a, 0xdf, 0x43, 0x69, 0x18, 0x99,
	0x33, 0x27, 0x38, 0xc7, 0x17, 0xb7, 0x3f, 0x7c, 0xce, 0x57, 0x7d, 0x8f, 0xd7, 0xd3, 0x06, 0x8d,
	0x06, 0x73, 0xcf, 0x0d, 0x68, 0x73, 0xad, 0x25, 0x1c, 0x0a, 0x48, 0xa0, 0x32, 0x8a, 0xcc, 0xc0,
	0xf2, 0x1d, 0x93, 0xe2, 0x0e, 0xd7, 0xa6, 0xa9, 0x79, 0xec, 0x68, 0x7d, 0xc5, 0x84, 0xe6, 0xda,
	0xa1, 0xd0, 0xfe, 0x25, 0x80, 0x78, 0x93, 0x0d, 0xfc, 0x70, 0xbd, 0x65, 0xe3, 0x2e, 0x80, 0x1e,
	0xba, 0x67, 0x6f, 0xf5, 0x9e, 0x2b, 0x67, 0xc4, 0x9b, 0x9a, 0x45, 0x46, 0xc1, 0xd1, 0x9f, 0x00,
	0x00, 0x00, 0xff, 0xff, 0x95, 0x07, 0x6b, 0x05, 0x52, 0x06, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// DriverTrackingClient is the client API for DriverTracking service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type DriverTrackingClient interface {
	// Send a stream of driver tracking messages
	Publish(ctx context.Context, opts ...grpc.CallOption) (DriverTracking_PublishClient, error)
	// Subscribe to driver tracking messages on a channel
	Subscribe(ctx context.Context, in *Subscription, opts ...grpc.CallOption) (DriverTracking_SubscribeClient, error)
}

type driverTrackingClient struct {
	cc *grpc.ClientConn
}

func NewDriverTrackingClient(cc *grpc.ClientConn) DriverTrackingClient {
	return &driverTrackingClient{cc}
}

func (c *driverTrackingClient) Publish(ctx context.Context, opts ...grpc.CallOption) (DriverTracking_PublishClient, error) {
	stream, err := c.cc.NewStream(ctx, &_DriverTracking_serviceDesc.Streams[0], "/pubnub.DriverTracking/Publish", opts...)
	if err != nil {
		return nil, err
	}
	x := &driverTrackingPublishClient{stream}
	return x, nil
}

type DriverTracking_PublishClient interface {
	Send(*DriverTrackingEnvelope) error
	Recv() (*PublishResponse, error)
	grpc.ClientStream
}

type driverTrackingPublishClient struct {
	grpc.ClientStream
}

func (x *driverTrackingPublishClient) Send(m *DriverTrackingEnvelope) error {
	return x.ClientStream.SendMsg(m)
}

func (x *driverTrackingPublishClient) Recv() (*PublishResponse, error) {
	m := new(PublishResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *driverTrackingClient) Subscribe(ctx context.Context, in *Subscription, opts ...grpc.CallOption) (DriverTracking_SubscribeClient, error) {
	stream, err := c.cc.NewStream(ctx, &_DriverTracking_serviceDesc.Streams[1], "/pubnub.DriverTracking/Subscribe", opts...)
	if err != nil {
		return nil, err
	}
	x := &driverTrackingSubscribeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type DriverTracking_SubscribeClient interface {
	Recv() (*DriverTrackingEnvelope, error)
	grpc.ClientStream
}

type driverTrackingSubscribeClient struct {
	grpc.ClientStream
}

func (x *driverTrackingSubscribeClient) Recv() (*DriverTrackingEnvelope, error) {
	m := new(DriverTrackingEnvelope)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// DriverTrackingServer is the server API for DriverTracking service.
type DriverTrackingServer interface {
	// Send a stream of driver tracking messages
	Publish(DriverTracking_PublishServer) error
	// Subscribe to driver tracking messages on a channel
	Subscribe(*Subscription, DriverTracking_SubscribeServer) error
}

// UnimplementedDriverTrackingServer can be embedded to have forward compatible implementations.
type UnimplementedDriverTrackingServer struct {
}

func (*UnimplementedDriverTrackingServer) Publish(srv DriverTracking_PublishServer) error {
	return status.Errorf(codes.Unimplemented, "method Publish not implemented")
}
func (*UnimplementedDriverTrackingServer) Subscribe(req *Subscription, srv DriverTracking_SubscribeServer) error {
	return status.Errorf(codes.Unimplemented, "method Subscribe not implemented")
}

func RegisterDriverTrackingServer(s *grpc.Server, srv DriverTrackingServer) {
	s.RegisterService(&_DriverTracking_serviceDesc, srv)
}

func _DriverTracking_Publish_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(DriverTrackingServer).Publish(&driverTrackingPublishServer{stream})
}

type DriverTracking_PublishServer interface {
	Send(*PublishResponse) error
	Recv() (*DriverTrackingEnvelope, error)
	grpc.ServerStream
}

type driverTrackingPublishServer struct {
	grpc.ServerStream
}

func (x *driverTrackingPublishServer) Send(m *PublishResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *driverTrackingPublishServer) Recv() (*DriverTrackingEnvelope, error) {
	m := new(DriverTrackingEnvelope)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _DriverTracking_Subscribe_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Subscription)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DriverTrackingServer).Subscribe(m, &driverTrackingSubscribeServer{stream})
}

type DriverTracking_SubscribeServer interface {
	Send(*DriverTrackingEnvelope) error
	grpc.ServerStream
}

type driverTrackingSubscribeServer struct {
	grpc.ServerStream
}

func (x *driverTrackingSubscribeServer) Send(m *DriverTrackingEnvelope) error {
	return x.ServerStream.SendMsg(m)
}

var _DriverTracking_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pubnub.DriverTracking",
	HandlerType: (*DriverTrackingServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Publish",
			Handler:       _DriverTracking_Publish_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "Subscribe",
			Handler:       _DriverTracking_Subscribe_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "pubnub.tracking.proto",
}

// LocationTrackingClient is the client API for LocationTracking service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type LocationTrackingClient interface {
	// Send a stream of location tracking messages
	Publish(ctx context.Context, opts ...grpc.CallOption) (LocationTracking_PublishClient, error)
	// Subscribe to location tracking messages on a channel
	Subscribe(ctx context.Context, in *Subscription, opts ...grpc.CallOption) (LocationTracking_SubscribeClient, error)
}

type locationTrackingClient struct {
	cc *grpc.ClientConn
}

func NewLocationTrackingClient(cc *grpc.ClientConn) LocationTrackingClient {
	return &locationTrackingClient{cc}
}

func (c *locationTrackingClient) Publish(ctx context.Context, opts ...grpc.CallOption) (LocationTracking_PublishClient, error) {
	stream, err := c.cc.NewStream(ctx, &_LocationTracking_serviceDesc.Streams[0], "/pubnub.LocationTracking/Publish", opts...)
	if err != nil {
		return nil, err
	}
	x := &locationTrackingPublishClient{stream}
	return x, nil
}

type LocationTracking_PublishClient interface {
	Send(*LocationTrackingEnvelope) error
	Recv() (*PublishResponse, error)
	grpc.ClientStream
}

type locationTrackingPublishClient struct {
	grpc.ClientStream
}

func (x *locationTrackingPublishClient) Send(m *LocationTrackingEnvelope) error {
	return x.ClientStream.SendMsg(m)
}

func (x *locationTrackingPublishClient) Recv() (*PublishResponse, error) {
	m := new(PublishResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *locationTrackingClient) Subscribe(ctx context.Context, in *Subscription, opts ...grpc.CallOption) (LocationTracking_SubscribeClient, error) {
	stream, err := c.cc.NewStream(ctx, &_LocationTracking_serviceDesc.Streams[1], "/pubnub.LocationTracking/Subscribe", opts...)
	if err != nil {
		return nil, err
	}
	x := &locationTrackingSubscribeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type LocationTracking_SubscribeClient interface {
	Recv() (*LocationTrackingEnvelope, error)
	grpc.ClientStream
}

type locationTrackingSubscribeClient struct {
	grpc.ClientStream
}

func (x *locationTrackingSubscribeClient) Recv() (*LocationTrackingEnvelope, error) {
	m := new(LocationTrackingEnvelope)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// LocationTrackingServer is the server API for LocationTracking service.
type LocationTrackingServer interface {
	// Send a stream of location tracking messages
	Publish(LocationTracking_PublishServer) error
	// Subscribe to location tracking messages on a channel
	Subscribe(*Subscription, LocationTracking_SubscribeServer) error
}

// UnimplementedLocationTrackingServer can be embedded to have forward compatible implementations.
type UnimplementedLocationTrackingServer struct {
}

func (*UnimplementedLocationTrackingServer) Publish(srv LocationTracking_PublishServer) error {
	return status.Errorf(codes.Unimplemented, "method Publish not implemented")
}
func (*UnimplementedLocationTrackingServer) Subscribe(req *Subscription, srv LocationTracking_SubscribeServer) error {
	return status.Errorf(codes.Unimplemented, "method Subscribe not implemented")
}

func RegisterLocationTrackingServer(s *grpc.Server, srv LocationTrackingServer) {
	s.RegisterService(&_LocationTracking_serviceDesc, srv)
}

func _LocationTracking_Publish_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(LocationTrackingServer).Publish(&locationTrackingPublishServer{stream})
}

type LocationTracking_PublishServer interface {
	Send(*PublishResponse) error
	Recv() (*LocationTrackingEnvelope, error)
	grpc.ServerStream
}

type locationTrackingPublishServer struct {
	grpc.ServerStream
}

func (x *locationTrackingPublishServer) Send(m *PublishResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *locationTrackingPublishServer) Recv() (*LocationTrackingEnvelope, error) {
	m := new(LocationTrackingEnvelope)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _LocationTracking_Subscribe_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Subscription)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LocationTrackingServer).Subscribe(m, &locationTrackingSubscribeServer{stream})
}

type LocationTracking_SubscribeServer interface {
	Send(*LocationTrackingEnvelope) error
	grpc.ServerStream
}

type locationTrackingSubscribeServer struct {
	grpc.ServerStream
}

func (x *locationTrackingSubscribeServer) Send(m *LocationTrackingEnvelope) error {
	return x.ServerStream.SendMsg(m)
}

var _LocationTracking_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pubnub.LocationTracking",
	HandlerType: (*LocationTrackingServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Publish",
			Handler:       _LocationTracking_Publish_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "Subscribe",
			Handler:       _LocationTracking_Subscribe_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "pubnub.tracking.proto",
}
